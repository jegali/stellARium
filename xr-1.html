<!DOCTYPE html>
<html lang="en">

<head>
	<title>Basic Scene with WebXR</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<!--<link type="text/css" rel="stylesheet" href="style.css">-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/three.js" crossorigin="anonymous"></script>
</head>

<body>

    <script>

	</script>

	<script type="module">
    // To start an AR scene with webXR, we can use a handy button provided by three.js
    // We first have to import it because it is a javascript module
    import { ARButton } from 'https://unpkg.com/three@0.126.0/examples/jsm/webxr/ARButton.js';
    
		let camera, scene, renderer;
		let centerGeometry;
        let mesh;
        let northMesh, eastMesh, southMesh, westMesh;
        var alpha=0, beta=0, gamma=0, heading = 0;

		window.onload = function () {
			// Check if is IOS 13 when page loads.
			if ( window.DeviceMotionEvent && typeof window.DeviceMotionEvent.requestPermission === 'function' ){
				// Everything here is just a lazy banner. You can do the banner your way.
				const banner = document.createElement('div')
				banner.innerHTML = `<div style="z-index: 1; position: absolute; width: 100%; background-color:#000; color: #fff"><p style="padding: 10px">Click here to enable DeviceMotion</p></div>`
				banner.onclick = ClickRequestDeviceMotionEvent // You NEED to bind the function into a onClick event. An artificial 'onClick' will NOT work.
				document.querySelector('body').appendChild(banner)
			}
			else {
				window.addEventListener('devicemotion',handleMotion);
				window.addEventListener('deviceorientation',handleOrientation);				
			}
		}

		function ClickRequestDeviceMotionEvent () {
			window.DeviceMotionEvent.requestPermission()
			.then(response => {
			  if (response === 'granted') {
				window.addEventListener('devicemotion',
				  () => { console.log('DeviceMotion permissions granted.') },
				  (e) => { throw e }
			  )} else {
				console.log('DeviceMotion permissions not granted.')
			  }
			})
			.catch(e => {
			  console.error(e)
			})
			window.DeviceOrientationEvent.requestPermission()
			.then(response => {
			  if (response === 'granted') {
				window.addEventListener('deviceorientation',handleOrientation)
			  } else {
				console.log('DeviceMotion permissions not granted.')
			  }
			})
			.catch(e => {
			  console.error(e)
			})			
		}	


		init();
		animate();

        function handleOrientation(event) {
			updateFieldIfNotNull('Orientation_a', event.alpha);
			updateFieldIfNotNull('Orientation_b', event.beta);
			updateFieldIfNotNull('Orientation_g', event.gamma);
			alpha = event.alpha;
			beta = event.beta;
			gamma = event.gamma;
			heading = compassHeading(event.alpha, event.beta, event.gamma);
			updateFieldIfNotNull('Orientation_heading', heading);
		}

        const compassHeading = (alpha, beta, gamma) => {

			// Convert degrees to radians
			const alphaRad = alpha * (Math.PI / 180);
			const betaRad = beta * (Math.PI / 180);
			const gammaRad = gamma * (Math.PI / 180);

			// Calculate equation components
			const cA = Math.cos(alphaRad);
			const sA = Math.sin(alphaRad);
			const cB = Math.cos(betaRad);
			const sB = Math.sin(betaRad);
			const cG = Math.cos(gammaRad);
			const sG = Math.sin(gammaRad);

			// Calculate A, B, C rotation components
			const rA = - cA * sG - sA * sB * cG;
			const rB = - sA * sG + cA * sB * cG;
			const rC = - cB * cG;

			// Calculate compass heading
			let compassHeading = Math.atan(rA / rB);

			// Convert from half unit circle to whole unit circle
			if(rB < 0) {
				compassHeading += Math.PI;
			}else if(rA < 0) {
				compassHeading += 2 * Math.PI;
			}

			// Convert radians to degrees
			compassHeading *= 180 / Math.PI;

			return compassHeading;
		};
		

		function handleMotion(event) {
		  //updateFieldIfNotNull('Accelerometer_gx', event.accelerationIncludingGravity.x);
		  //updateFieldIfNotNull('Accelerometer_gy', event.accelerationIncludingGravity.y);
		  //updateFieldIfNotNull('Accelerometer_gz', event.accelerationIncludingGravity.z);

		  //updateFieldIfNotNull('Accelerometer_x', event.acceleration.x);
		  //updateFieldIfNotNull('Accelerometer_y', event.acceleration.y);
		  //updateFieldIfNotNull('Accelerometer_z', event.acceleration.z);

		  //updateFieldIfNotNull('Accelerometer_i', event.interval, 2);

		  //updateFieldIfNotNull('Gyroscope_z', event.rotationRate.alpha);
		  //updateFieldIfNotNull('Gyroscope_x', event.rotationRate.beta);
		  //updateFieldIfNotNull('Gyroscope_y', event.rotationRate.gamma);
		}



		function updateFieldIfNotNull(fieldName, value, precision=10){
			if (value != null)
			document.getElementById(fieldName).innerHTML = value.toFixed(precision);	
		}

		function init() {
			const container = document.createElement('div');
			document.body.appendChild(container);

			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 40);

			renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			// This next line is important to to enable the renderer for WebXR
			renderer.xr.enabled = true; // New!
			container.appendChild(renderer.domElement);

			var light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
			light.position.set(0.5, 1, 0.25);
			scene.add(light);

			//const geometry = new THREE.IcosahedronGeometry(0.1, 1);
			const northGeometry = new THREE.BoxGeometry( 0.2, 0.2, 0.2 );
			const greenMaterial = new THREE.MeshPhongMaterial({
				color      :  new THREE.Color("rgb(0,200,0)"),
				shininess  :  6,
				flatShading:  true,
				transparent: 1,
				opacity    : 0.8
			});

			const eastGeometry = new THREE.BoxGeometry( 0.2, 0.2, 0.2 );
			const redMaterial = new THREE.MeshPhongMaterial({
				color      :  new THREE.Color("rgb(200,0,0)"),
				shininess  :  6,
				flatShading:  true,
				transparent: 1,
				opacity    : 0.8
			});

			const southGeometry = new THREE.BoxGeometry( 0.2, 0.2, 0.2 );
			const yellowMaterial = new THREE.MeshPhongMaterial({
				color      :  new THREE.Color("rgb(200,200,0)"),
				shininess  :  6,
				flatShading:  true,
				transparent: 1,
				opacity    : 0.8
			});

			const westGeometry = new THREE.BoxGeometry( 0.2, 0.2, 0.2 );
			const blueMaterial = new THREE.MeshPhongMaterial({
				color      :  new THREE.Color("rgb(0,0,200)"),
				shininess  :  6,
				flatShading:  true,
				transparent: 1,
				opacity    : 0.8
			});

      
	        centerGeometry = new THREE.Group();
			centerGeometry.position.set(0,0,0);
	  
			northMesh = new THREE.Mesh(northGeometry, greenMaterial);
			northMesh.position.set(-1, 0, 0);
			centerGeometry.add(northMesh);

			eastMesh = new THREE.Mesh(eastGeometry, redMaterial);
			eastMesh.position.set(0, 0, -1);
			centerGeometry.add(eastMesh);

			southMesh = new THREE.Mesh(southGeometry, yellowMaterial);
			southMesh.position.set(1, 0, 0);
			centerGeometry.add(southMesh);

			westMesh = new THREE.Mesh(westGeometry, blueMaterial);
			westMesh.position.set(0, 0, 1);
			centerGeometry.add(westMesh);
			
			scene.add(centerGeometry);

			centerGeometry.rotation.y = THREE.Math.degToRad(heading-90.0);
	

			// Add the AR button to the body of the DOM
			document.body.appendChild(ARButton.createButton(renderer));

			window.addEventListener('resize', onWindowResize, false);
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function animate() {
			renderer.setAnimationLoop(render);
		}

        let degrees = 0;

        function rotateSystem() {
		  //centerGeometry.rotation.y = THREE.Math.degToRad(heading-90);
		}
		
		function render() { 
			rotateSystem();
			renderer.render(scene, camera);
		}

	</script>
	
	<div style="z-index: 10002; position: absolute;">
	<h4 style="margin-top:0.75rem;">Orientation</h4>
	<ul>
	  <li>X-axis (&beta;): <span id="Orientation_b">0</span><span>&deg;</span></li>
	  <li>Y-axis (&gamma;): <span id="Orientation_g">0</span><span>&deg;</span></li>
	  <li>Z-axis (&alpha;): <span id="Orientation_a">0</span><span>&deg;</span></li>
	  <li>compassHeading: <span id="Orientation_heading">0</span><span>&deg;</span></li>
	</ul>
	</div>
	
</body>

</html>